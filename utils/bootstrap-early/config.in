# The packages that we'll be building during bootstrap-early
p_early="@p_early@"

INSTALLROOT=@INSTALLROOT@
BUILDROOT=@BUILDROOT@
PREFIX_EARLY=@PREFIX_EARLY@

# NOTE: The CLFS book puts the cross-compilation toolcahin in /cross-tools
#       and the cross-compiled temporary native compilation toolchain in
#       /tools.  Both of these are actually symlinks pointing into
#       $CLFS/cross-tools and $CLFS/tools.  I don't remember the rationale
#       for doing this at the moment, but for simplicity's sake we're going
#       to follow the CLFS book to a tee (at least, early on).
#
#       For the record, ditching the symlinks and installing directly into
#       $CLFS does indeed cause breakage in the CLFS instructions...
PREFIX_CROSS=@PREFIX_CROSS@
PREFIX_FINAL=@PREFIX_FINAL@


# --- CLFS Variables ------------------------------------------------------

# these cannot be set (CLFS book says so, I assume because massive breakage
# will ensue)
unset CFLAGS
unset CXXFLAGS

# this is where our baby filesystem lives while we're building it.  at the
# end of the bootstrap-stage1 stage, we'll move this to $INSTALLROOT.
# keeping it inside a different directory until then make maintainence
# easier (e.g., chown -R root:root $CLFS won't mess with our source tree)
CLFS=$BUILDROOT/baby

# set host and target variables.
#
# NOTE: I would have called these MACHTYPE_HOST, MACHTYPE_TARGET, and
#       MACHTYPE_TARGET32, but we're using the CLFS variables so we can
#       cut-n-paste build scripts.
#
# NOTE: This needs to NOT be a normal host string just in case our target
#       system actually happens to be the same as our host system (which
#       would break the cross-compilation scheme we're using here).
#
export CLFS_HOST=@CLFS_HOST@
export CLFS_TARGET=@CLFS_TARGET@
export CLFS_TARGET32=@CLFS_TARGET32@


# these variables seem like overkill, but are used in the CLFS book, so
# we'll follow suit.
#
# NOTE: We also use these variables to determine what we're building.  If we're
#       buliding plain old 32bit, only BUILD32 will be set.  Pure64 x86_64 will
#       have just BUILD64 set.  x86_64 Multilib will have both.
#
# x86: BUILD32 and BUILD64 are both unused
#
# x86_64 pure: BUILD64 is used for bootstrap-cross eglibc (and a conditional in
#              binutils), bootstrap-stage1 everything.  It's completely unused
#              in bootstrap-stage2 and final system
#
# x86_64 multi: BUILD64 and BUILD32 are used for bootstrap-cross eglibc*.  All
#               of bootstrap-stage1 and bootstrap-stage2 is built using BUILD64
#               ONLY.  Final system software is built using both BUILD32 and
#               BUILD64.
#
# If we follow that scheme (i.e, don't set either if arch is x86), then having
# BUILD32 set means we're x86_64 multilib... which is going to get pretty
# confusing... perhaps we should just have a MULTILIB variable?
#
export BUILD32=@BUILD32@
export BUILD64=@BUILD64@

# NOTE: This variable seems to only be set in the embedded CLFS book and
#       is used by busybox and the linux kernel.
#
# FIXME: shouldn't the x86 kernel use an ARCH newer than 386?  didn't they just
#        remove 386 support a few releases ago?  CLFS book is using i386, but
#        we've got our TARGET triplet set up as i686, so I'm going to use
#        that...
#
# FIXME: the kernel section looks in arch/$CLFS_ARCH/boot for the finished
#        kernel... is this correct for i686?
#
export CLFS_ARCH=@CLFS_ARCH@
