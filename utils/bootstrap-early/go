#!/bin/bash

# which packages need to be built should be determined by configure script

# should set toplevel via autoconf?
toplevel=$PWD/../..

# source our common variables and functions
. $toplevel/utils/bootstrap-early/functions


packages=""

# add rsync so we can use it to copy source trees for packages that don't
# support out-of-tree builds
packages+=" rsync"

# gzip is needed so we can ensure tar can extract from tar.gz files
#
# FIXME: lots of the following types of warnings, then a failure on my
#        netbook:
#
#        cc1: warning: command line option "-Wabi" is valid for C++/ObjC++
#        but not for C
packages+=" gzip"

# bzip2 is also needed to make sure we can extract all our source tarballs
packages+=" bzip2"

# xz is needed to build syslinux (and potentially for uncompressing
# source tarballs, patches, etc)
packages+=" xz"

# tar is needed to make sure that we have a new enough version to extract
# tarballs compressed with xz and lzma
packages+=" tar"

# help2man is needed to build man pages for libtool and texinfo after
# running autoreconf
packages+=" help2man"

# install these to make sure the rest of the build is done using the GNU
# build tools we test against
#
# NOTE: This is the bootstrap black whole mentioned elsewhere.  I have
#       sucessfully worked around it a few different ways.
#
#       - Installed automake-1.12.4 from source.tar.xz in /scrap/staging and
#         tweaked environment vars appropriately (e.g., PATH,
#         LD_LIBRARY_PATH).
#
#       - My netbook already had automake 1.11.1 installed and configured
#         properly in /usr/local (had done it via source.tar.xz a while
#         back).  Of course, it ALSO had autoconf, m4, gettext, libtool,
#         make, pkg-config, and bison of similar vintage installed... so
#         just installing automake v1.11.1 might not be enough.
#
# NOTE: I've placed requirements in comments for each of these, for future
#       reference.
packages+=" m4" # automake >= 1.11.1
packages+=" autoconf" # m4 >= 1.4.16
packages+=" automake" # autoconf >= 2.69
packages+=" gettext" # too painful, so we use a dist tarball
packages+=" libtool" # warned about libtool.m4 bootstrap failure
packages+=" pkg-config" # glib bits need libtool
packages+=" make" # automake >= 1.11.1, gettext >= 0.18.1, pkg-config

# FIXME: packages+=" gperf"
# FIXME: flex?
# FIXME: graphviz?
# FIXME: valgrind?
packages+=" bison"

# to ensure that we don't inadvertantly use a modified version with
# non-standard extensions to build our filesystems
#
# NOTE: e2fsprogs > v1.41.7 may not compile on systems with really old kernel
#       headers.  This can be worked around by hacking it's misc/Makefile.in to
#       not compile e4defrag.  It can also be worked around by rewinding the
#       e2fsprogs submodule to v1.41.7 prior to building bootstrap-early, then
#       fast forwarding it back to the modern day.  ;-)
packages+=" e2fsprogs"

# might also want to make sure that the host system has a usable ncurses
# (and ncurses-devel) library.  otherwise we can't run the 'menuconfig'
# target for kernel and busybox configuration
#
# NOTE: Both the kernel and busybox fail to look for ncurses anywhere
#       other than in /usr... so in order to actually make use of
#       this, their source trees will need to be patched to point to
#       our bootstrap-early libraries.
packages+=" ncurses"



build()
{
    case "$1" in
	rsync)
	    # seems to have a parallel build problem... (still true as of
	    # v3.0.9)
	    JOBCOUNT=1 build_generic $1 --prefix=$PREFIX_EARLY || exit 1
	    ;;
        e2fsprogs)
            # work around e4defrag problem mentioned above
            sed -i.bak 's|.*E4DEFRAG_PROG=|#FOO|' \
                $toplevel/src/e2fsprogs/misc/Makefile.in &&
            build_generic $1 --prefix=$PREFIX_EARLY &&
            cp $toplevel/src/e2fsprogs/misc/Makefile.in.bak \
                $toplevel/src/e2fsprogs/misc/Makefile.in || exit 1
            ;;
	ncurses)
	    build_generic $1 --prefix=$PREFIX_EARLY --with-shared || exit 1
	    ;;
	help2man)
	    build_generic $1 --prefix=$PREFIX_EARLY --disable-nls || exit 1
	    ;;
	pkg-config)
	    # NOTE: Some systems need march to be >= i486 to build the
	    #       included glib bits here...
            #
            # NOTE: The internal glib snapshot can be used to remove a host
            #       system dependency, but if the host system has glib and a
            #       really old kernel that doesn't define PR_SET_NAME
            #       (<2.6.9?), it'll fail to compile.
            #
            # FIXME: autoconf for this?
	    CPPFLAGS=-march=i486 \
		build_generic $1 --prefix=$PREFIX_EARLY \
		--with-internal-glib || exit 1
	    ;;
        bison)
            # this guy needs to update submodules
            #
            # NOTE: This is kinda involved because I don't want to have to
            #       maintain a fork of bison just to make it find our autoconf
            #       submodule instead of going out to gnu.org...
            #
            #       The sed statement replaces remote git URLs with ../ to use
            #       our other submodules, then we explicitly only update the
            #       autoconf module (i.e., we skip gnulib which is referenced
            #       directly via the GNULIB_SRCDIR variable).
            pushd $toplevel/src/bison && 
            sed -i 's|git://.*/|../|' .gitmodules &&
            git submodule update --init submodules/autoconf &&
            popd &&
	    build_generic $1 --prefix=$PREFIX_EARLY || exit 1
            ;;
        bzip2)
            # Doesn't have configure
            build_in_tree=1 setup_generic $1 &&
            pushd $builddir &&
            make -j$JOBCOUNT && make PREFIX=$PREFIX_EARLY install &&
            popd || exit 1
            ;;
	*)
	    build_generic $1 --prefix=$PREFIX_EARLY || exit 1
	    ;;
    esac
}


# FIXME: add code here to configure sudo. for now, I've set up my host
#        system to give my user unlimited unpassword root access...


# create a /tools symlink on the host system pointing to $CLFS/tools
# so that we don't have to go crazy sorting out chroot vs non-chroot paths
# throughout.  this would probably involve having to sort out 2 sets of
# patches for each affected package, so requiring root priveledges for just
# this one thing seems like an ok compromise.



mkdir -p $CLFS$PREFIX_FINAL || exit 1
if [ "`readlink $PREFIX_FINAL 2>/dev/null`" != "$CLFS$PREFIX_FINAL" ]; then
    echo "need root priveledges to create $PREFIX_FINAL symlink"
    sudo ln -s $CLFS$PREFIX_FINAL $PREFIX_FINAL || exit 1
fi
mkdir -p $CLFS$PREFIX_CROSS || exit 1
if [ "`readlink $PREFIX_CROSS 2>/dev/null`" != "$CLFS$PREFIX_CROSS" ]; then
    echo "need root priveledges to create $PREFIX_CROSS symlink"
    sudo ln -s $CLFS$PREFIX_CROSS $PREFIX_CROSS || exit 1
fi

# build and install each needed package
for p in $packages; do
    echo "building bootstrap-early package: $p"
    build $p || exit 1
done
