# -*- mode: sh -*-

packagedir=$toplevel/packages
sourcedir=$toplevel/src

INSTALLROOT=$toplevel/..
BUILDROOT=$toplevel/.build
PREFIX_EARLY=$BUILDROOT/bootstrap-early

# NOTE: The CLFS book puts the cross-compilation toolcahin in /cross-tools
#       and the cross-compiled temporary native compilation toolchain in
#       /tools.  Both of these are actually symlinks pointing into
#       $CLFS/cross-tools and $CLFS/tools.  I don't remember the rationale
#       for doing this at the momment, but for simplicity's sake we're going
#       to follow the CLFS book to a tee (at least, early on).
#
#       For the record, ditching the symlinks and installing directly into
#       $CLFS does indeed cause breakage in the CLFS instructions...
PREFIX_CROSS=/cross-tools
PREFIX_FINAL=/tools


# --- CLFS Variables ------------------------------------------------------

# these cannot be set (CLFS book says so, I assume because massive breakage
# will ensue)
unset CFLAGS
unset CXXFLAGS

# this is where our baby filesystem lives while we're building it.  at the
# end of the bootstrap-stage1 stage, we'll move this to $INSTALLROOT.
# keeping it inside a different directory until then make maintainence
# easier (e.g., chown -R root:root $CLFS won't mess with our source tree)
CLFS=$BUILDROOT/baby

# set host and target variables.
#
# NOTE: I would have called these MACHTYPE_HOST, MACHTYPE_TARGET, and
#       MACHTYPE_TARGET32, but we're using the CLFS variables so we can
#       cut-n-paste build scripts.
#
# NOTE: The CLFS book manipulates the $MACHTYPE system variable to determine
#       CLFS_HOST, which works when $MACHTYPE is something like
#       'i386-redhat-linux-gnu' (fedora, 32bit), but sometimes it's just set
#       to something like 'i686' (SUSE, 32bit).
#
# FIXME: this should eventually be done via autoconf
#
# NOTE: This needs to NOT be a normal host string just in case our target
#       system actually happens to be the same as our host system (which
#       would break the cross-compilation scheme we're using here).
export CLFS_HOST="i686-cross-linux-gnu"
export CLFS_TARGET="x86_64-ruckus-linux-gnu"
export CLFS_TARGET32="i686-pc-linux-gnu"

# these variables seem like overkill, but are used in the CLFS book, so
# we'll follow suit.
#
# NOTE: We also use these variables to determine what we're building.  If we're
#       buliding plain old 32bit, only BUILD32 will be set.  Pure64 x86_64 will
#       have just BUILD64 set.  x86_64 Multilib will have both.
#
# FIXME: they should probably also be set via autoconf
export BUILD32="-m32"
export BUILD64="-m64"

# -------------------------------------------------------------------------

# FIXME: should also get determined by autoconf
#
# FIXME: where did this variable come from?  i don't see CLFS using it...
#        they're in the build scripts for busybox and the kernel.
export ARCH_TARGET=x86_64



# this variable tells bootstrap scripts where to find gnulib, to avoid them
# all trying to create their own local clone
export GNULIB_SRCDIR=$toplevel/src/gnulib

# this variable tells bootstrap scripts (probably just cpio and tar) to use
# our paxutils submodule instead of cloning their own.
export PAXUTILS_SRCDIR=$toplevel/src/paxutils

# this variable tells bootstrap scripts to not download new po files via
# rsync
export SKIP_PO=t

# the presence of this file will indicate that we're running in the stage2
# bootstrap environment (i.e., booted up into baby system building the rest
# of the bootstrap utilities)
RUCKUS_BOOTSTRAP_STAGE2_FILE=/.ruckus_bootstrap_stage2

# only add BOOTSTRAP_EARLY and BOOTSTRAP_CROSS to PATH if we haven't booted
# into the stage2 bootstrap system yet.
if [ ! -f $RUCKUS_BOOTSTRAP_STAGE2_FILE ]; then
    # setup environment to use our bootstrap-early stuff
    export PATH=$PREFIX_EARLY/bin:$PREFIX_EARLY/sbin:$PATH
    export MANPATH=$PREFIX_EARLY/man:$PREFIX_EARLY/share/man:$MANPATH
    export PKG_CONFIG_PATH=$PREFIX_EARLY/lib/pkg-config:$PKG_CONFIG_PATH
    if [ -z "$LD_LIBRARY_PATH" ]; then
	export LD_LIBRARY_PATH=$PREFIX_EARLY/lib
    else
	export LD_LIBRARY_PATH=$PREFIX_EARLY/lib:$LD_LIBRARY_PATH
    fi
    
    # and now add in the bootstrap-cross tools
    export PATH=$PREFIX_CROSS/bin:$PREFIX_CROSS/sbin:$PATH
    export MANPATH=$PREFIX_CROSS/man:$PREFIX_CROSS/share/man:$MANPATH
    export PKG_CONFIG_PATH=$PREFIX_CROSS/lib/pkg-config:$PKG_CONFIG_PATH
    if [ -z "$LD_LIBRARY_PATH" ]; then
	export LD_LIBRARY_PATH=$PREFIX_CROSS/lib
    else
	export LD_LIBRARY_PATH=$PREFIX_CROSS/lib:$LD_LIBRARY_PATH
    fi
fi

# this variable will be used by default to determine the number of jobs to
# pass into make.
#
# FIXME: this should be configurable via autoconf?
export CPUCOUNT=$(grep "^processor" /proc/cpuinfo | wc -l)
export JOBCOUNT=$((CPUCOUNT+1))
export JOBCOUNT_KBUILD=$((CPUCOUNT*4))

# make sure nullglob is turned on.  this makes a glob that doesn't match any
# files expand to '' rather than the glob pattern itself.  we want this
# behavior so we can do the following (all over the place):
#
# for p in might_be_patches_in_here/*.patch; patch -Np1 < $x
#
# without nullglob turned on, that issues an error if there aren't any
# patches.
#
# FIXME: shopt is bash specific...  ash (busybox's shell used in
#        bootstrap-stage2) doesn't like the shopt command.  i don't even
#        know if ash's default behavior is what we want... better look into
#        it.
#
shopt -s nullglob >/dev/null 2>&1

# turn on dotglob.  this makes globs include 'hidden' files, like .foo.  i'm
# used to this behavior by default, so having this turned off keeps
# introducing bugs in my scripts.
#
# FIXME: shopt is bash specific.  look into ash's behavior.
shopt -s dotglob > /dev/null 2>&1

# NOTE: make sure we have pushd/popd, since we use it all over the place
#
# NOTE: these two aliases are only set if a check for pushd fails.
need_pushd=0
pushd / >/dev/null 2>&1 && popd >/dev/null || need_pushd=1
if [ $need_pushd -eq 1 ]; then
    #echo "defining pushd and popd"
    alias pushd='wd="$(pwd) ${wd}"; cd'
    alias popd='cd ${wd%% *}; wd=${wd#* }'
fi

# NOTE: and this is so we can have the illusion of sudo in stage2, via
#       busybox's su.  note that this only works because root doesn't have a
#       password in the bootstrap system.  the only real benefit of this
#       really is that we can maintain consistency with the rest of the
#       scripts, and we don't have to wory about quoting the argument to su.
#
# NOTE: this alias is only set if a check for sudo fails.
need_sudo=0
which sudo >/dev/null || need_sudo=1
if [ $need_sudo -eq 1 ]; then
    sudo()
    {
	su -c "cd $PWD; $*"
    }
fi

# define generic builder method.  this does some magic to set up a build
# tree based on what's stored in sourcedir (ie, a source tree or a source
# tarball).  first arg is package name, the rest are passed on to configure.
build_generic()
{
    setup_generic $* &&
    configure_generic $* &&
    compile_generic $* || exit 1
}


setup_generic()
{
    p=$1
    shift
    builddir=$PWD/.build/$p
    source=$sourcedir/$p
    configure=$source/configure
    #autoreconf="no"
    mkdir -p $builddir

    # figure out if we're using a source tarball or an already unpacked
    # source tree.  we do this by looking for Makefile, configure,
    # configure.ac, or configure.in in the sourcedir
    if [ ! -f $source/Makefile ] && [ ! -x $configure ] && [ ! -f $configure.ac ] && [ ! -f $configure.in ]; then
	echo "using source tarball"
	# using tarball.  need to modify some variables and extract the
	# source tree
	#autoreconf="no"
	mkdir -p $builddir/source || exit 1
	pushd $builddir/source
	echo "checking for previously extracted source tree..."
	# FIXME: I think the following check is what prompted me to globally
	#        turn on bash's nullglob option...
	if [ "." == "`ls -d ./*`" ]; then
	    echo "extracting..."
	    tar xf $source/*.tar.* || exit 1
	fi
	pushd ./* &&
	source=$PWD &&
	configure=$source/configure &&
	popd &&
	builddir=$builddir/build &&
	mkdir -p $builddir || exit 1
	popd
	# also apply any patches in the sourcedir
	pushd $source
	# only do this if we haven't previously configured
	if [ ! -f $builddir/Makefile ]; then
	    # FIXME: this following line also requires nullglob...
	    for p in $sourcedir/$p/*.patch; do
		#autoreconf="yes"
		echo "applying patch: $p"
		patch -Np1 < $p || exit 1
	    done
	fi
	popd

    elif [ -n "$build_in_tree" ]; then
	# this is a special case for source trees we have that can't handle
	# out-of-tree builds for one reason or another.  instead of setting
	# up for out-of-tree, it simply rsync's the source into where it
	# would be if we were using a tarball
	echo "copying source tree from $source to $builddir/source..."
	rsync -a --delete $source/ $builddir/source || exit 1
	source=$builddir/source
	builddir=$builddir/build
	mkdir -p $builddir || exit 1
    fi

    if [ -n "$build_in_tree" ]; then
	# some packages can't build out-of-tree.  we'll replace $builddir
	# with a symlink to our local source tree
	rmdir $builddir && ln -s $source $builddir || exit 1
	configure=./configure
    fi

    # apply additional patches, if specified
    if [ -n "$patches" ] && [ ! -f $builddir/Makefile ]; then
	pushd $source || exit 1
	for p in $patches; do
	    echo "applying additional patch: $p"
	    patch -Np1 < $p || exit 1
	done
	popd
    fi

    # We need to make sure the sourcetree has already been bootstrapped.
    if [ ! -x $configure ]; then
	autoreconf_generic || exit 1
    fi

    echo source: $source
    echo builddir:  $builddir
    echo configure: $configure
}


configure_generic()
{
    p=$1
    shift
    #builddir=.build/$p
    #configure=$sourcedir/$p/configure
    #mkdir -p $builddir
    echo autoreconf: $autoreconf

    # go guild it!
    pushd $builddir || exit 1
    # only explicitly run configure the first time
    if [ ! -f Makefile ] || [ -n "$autoreconf" ]; then
	if [ ! -x $configure ] || [ -n "$autoreconf" ]; then
	    autoreconf_generic || exit 1
	fi
	$configure $* || exit 1
    fi
    popd
}


autoreconf_generic()
{
    pushd $source || exit 1

    # make sure we're not using the cross-compiler, but keep track if we
    # were so we can turn it back on before returning
    should_cross_compile=$cross_compile
    unset_cross_compile

    # choose a bootstrap method
    nothing_to_do=
    if [ -x ./bootstrap.sh ]; then
	echo "./bootstrap.sh..."
	./bootstrap.sh || exit 1
    elif [ -x ./bootstrap ]; then
	echo "./bootstrap..."
	./bootstrap || exit 1
    elif [ -x ./autogen.sh ]; then
	echo "./autogen.sh..."
	./autogen.sh || exit 1
    elif [ -f ./configure.in ] || [ -f ./configure.ac ]; then
	echo "autoreconf..."
	autoreconf --force --install || exit 1
    else
	nothing_to_do=true
	echo "autoreconf_generic: doing nothing..."
    fi

    # make sure we're unconfigured.  some bootstrap and autogen.sh scripts
    # run configure at the end, but not all.  we have to be able to assume
    # consistent behavior here, so do a make distclean if Makefile exists
    # already.
    #
    # NOTE: This isn't just done for consistency.  Some packages (e.g.,
    #       make) will fail to configure for out-of-tree building if they
    #       were previously configured for in-tree building (e.g., by simply
    #       running configure from within the source tree).  You end up
    #       getting an error saying that the sources are already configured
    #       and you need to make distclean first.
    if [ -z "$nothing_to_do" ] && [ -f Makefile ]; then
	make distclean || exit 1
    fi

    # if we were previously set up to use our cross-compiler.  set it back
    # up now
    if [ -n "$should_cross_compile" ]; then
	set_cross_compile
    fi

    popd
}


compile_generic()
{
    p=$1
    shift
    #builddir=.build/$p
    #configure=$sourcedir/$p/configure
    #mkdir -p $builddir

    # if we're in the stage2 bootstrap, we need to install as root user.
    if [ -f $RUCKUS_BOOTSTRAP_STAGE2_FILE ]; then
	SUDO=sudo
    else
	SUDO=
    fi

    pushd $builddir &&
    make -j$JOBCOUNT && $SUDO make install &&
    popd || exit 1
}


set_cross_compile()
{
    export CC="${CLFS_TARGET}-gcc"
    export CXX="${CLFS_TARGET}-g++"
    export AR="${CLFS_TARGET}-ar"
    export AS="${CLFS_TARGET}-as"
    export RANLIB="${CLFS_TARGET}-ranlib"
    export LD="${CLFS_TARGET}-ld"
    export STRIP="${CLFS_TARGET}-strip"

    export CC="${CC} ${BUILD64}"
    export CXX="${CXX} ${BUILD64}"

    export cross_compile=true
}


unset_cross_compile()
{
    export CC=
    export CXX=
    export AR=
    export AS=
    export RANLIB=
    export LD=
    export STRIP=
    export cross_compile=
}
