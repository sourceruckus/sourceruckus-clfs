#!/bin/bash

# should set toplevel via autoconf?
toplevel=$PWD/../..

# source our common variables and functions
. $toplevel/utils/bootstrap-early/functions

# NOTE: The bootstrap-stage2 scripts run using busybox's ash shell.  That
#       meens there are a few bash-isms that we MUST avoid using.  Here's a
#       list of the ones that come to mind:
#
#       No += support, so OPTS+=' --foo' has to be OPTS="$OPTS --foo".
#
# FIXME: I don't know if nullglob or dotglob options exist in ash...


build()
{
    # set some common variables for all targets
    OPTS="--prefix=$PREFIX_FINAL"

    if [ -n "$BUILD64" ]; then
	OPTS="$OPTS --libdir=$PREFIX_FINAL/lib64"
    fi

    OPTS="$OPTS --disable-static"
    OPTS="$OPTS --enable-shared"
    OPTS="$OPTS --disable-nls"

    case "$1" in
	tcl)
	    # NOTE: we can't use setup_generic here because it assumes we're
	    #       gonna try to build in the toplevel direcory of the
	    #       source tree...  which isn't the case for tcl.
	    p=tcl
	    builddir=$PWD/.build/$p
	    source=$sourcedir/$p/unix
	    configure=$source/configure
	    mkdir -p $builddir

	    echo source: $source
	    echo builddir:  $builddir
	    echo configure: $configure

            # increase memory size for regular expressions
            pushd $builddir &&
            sed -i s/500/5000/ generic/regc_nfa.c &&
            popd || exit 1

	    configure_generic $1 $OPTS && 
	    compile_generic $1 || exit 1

	    # and do a bit of extra work
	    pushd $builddir &&
	    sudo make install-private-headers &&
	    sudo ln -s tclsh8.6 $PREFIX_FINAL/bin/tclsh
	    popd || exit 1

	    ;;

	expect)

	    if [ -n "$BUILD64" ]; then
		OPTS="$OPTS --with-tcl=$PREFIX_FINAL/lib64"
	    else
		OPTS="$OPTS --with-tcl=$PREFIX_FINAL/lib"
	    fi
	    OPTS="$OPTS --with-tclinclude=$PREFIX_FINAL/include"

	    setup_generic $1 &&
	    configure_generic $1 $OPTS || exit 1

	    # custom build script.  setting SCRIPTS like this causes expect
	    # to leave out a bunch of stuff we don't need right now.
	    pushd $builddir &&
	    make -j$JOBCOUNT &&
	    sudo make SCRIPTS="" install &&
	    popd || exit 1
	    ;;

        perl)
            # FIXME: fill me in
            ;;

        python)
            # FIXME: fill me in
            ;;

        srp)
            # FIXME: fill me in
            ;;

	*)
	    build_generic $1 $OPTS || exit 1
	    ;;
    esac
}


packages=""
packages="$packages tcl"
packages="$packages expect"
packages="$packages dejagnu"

# FIXME: This is now in CLFS Chapter 6, Constructing a Temporary System.  Not
#        sure why or when it got moved there.  Did it fail to cross-compile for
#        me at some point?
packages="$packages check"

# NOTE: This is in CLFS Chapter 10, Installing Basic System Software, but
#       installs in /tools so I've moved it up here.  CLFS even has a note
#       saying that it really should be in Chapter 6, but it's a pain to
#       cross-compile and not needed for 1st boot of the temporary system, so
#       building here is easier to maintain.
packages="$packages perl"

# srp
packages="$packages python"
packages="$packages srp"

# NOTE: Probably not strictly a requirement... but otherwise we won't be able
#       to do any git tweakage (submodule, checkout, etc) in the build
#       environment.
#
# FIXME: If we can get away with building this here w/out having to add a bunch
#        of extra stuff, we should.
#
#packages="$packages git"


# FIXME: might want the following if we're building bare-metal instead of as a
#        xen domU.
#
# sshd (openssl/openssh, or dropbear (the embedded alernative))
#packages="$packages openssl"
#packages="$packages openssh"
#
# dhcp/dns
#packages="$packages dnsmasq"
#
# dev tools
#packages="$packages rsync"
#packages="$packages git"
#packages="$packages readline"
#packages="$packages emacs"
#packages="$packages zsh"


# FIXME: should this bootstrap environment actually BE my tiniest embedded
#        image?  this would allow us to build a console-only version of emacs
#        for use on embedded systems, but replace it (via the srp build system)
#        with a fully X-capable version later on...


cd $toplevel/utils/bootstrap-stage2
mkdir -p $PWD/.build

for p in $packages; do
    echo "building bootstrap-stage2 package: $p"
    build $p || exit 1
done

exit 0





# NOTE: if the bootstrap system is feature-complete for my embedded
#       server, i can leave it booted up all the time (as apposed to
#       rebooting into fedora).  here's what i would need
#
#       www: i don't do anything fancy here... i think the busybox
#       httpd will suffice.  (although i'll need ImageMagick for photo
#       thumbnail generation)
#
#       nfs: i think i'd have to add nfs-utils for this...  don't
#       think busybox does nfs server.
#
#       dhcp: busybox dhcpd/dnsd functionality isn't sufficient.
#       we'll add dnsmasq to take care of dhcpd and dynamic dns.
#
#       ssh: i need to be able to ssh into the box...  openssl/openssh
#       or dropbear?
#
#       dev tools: i'm gonna need rsync and git.  would probably like
#       to have emacs and zsh, too.
#
#       python: probably need this to use media_utils, etc
#
#       multimedia: speaking of media_utils... that would require at
#       least having ImageMagick.  Maybe also need dvgrab and all the
#       multimedia libs up to ffmpeg...
#
#       syslog: can use busybox's syslogd and klogd, but have to add
#       init scripts or something...


# FIXME: considering including extra documentation tools in here as well, so
#        we don't have to wory about tools not existing yet in the bootstrap
#        environment.
#packages+=" tetex"
#packages+=" asdf"
#packages+=" xfig"
#packages+=" transfig"
#packages+=" netpbm"
#packages+=" latex2html"
#packages+=" graphviz"
#packages+=" doxygen"
#packages+=" ghostscript"
#packages+=" gtkdoc"

#packages+=" freetype"
#packages+=" docbook-xml"
#packages+=" docbook-xsl"
#packages+=" libxml2"
#packages+=" libxslt"
#packages+=" fontconfig"
