#!/bin/bash

# should set toplevel via autoconf?
toplevel=$PWD/../..

# source our common variables and functions
. $toplevel/utils/bootstrap-early/functions

# extra variables for the final bootstrap stage
export CC="${MACHTYPE_TARGET}-gcc"
export CXX="${MACHTYPE_TARGET}-g++"
export AR="${MACHTYPE_TARGET}-ar"
export AS="${MACHTYPE_TARGET}-as"
export RANLIB="${MACHTYPE_TARGET}-ranlib"
export LD="${MACHTYPE_TARGET}-ld"
export STRIP="${MACHTYPE_TARGET}-strip"


build()
{
    # set some common variables for all targets
    CC="${CC} ${BUILD64}"
    CXX="${CXX} ${BUILD64}"
    OPTS="--prefix=$PREFIX_FINAL"
    OPTS+=" --build=${MACHTYPE_HOST}"
    OPTS+=" --host=${MACHTYPE_TARGET}"
    OPTS+=" --libdir=$PREFIX_FINAL/lib64"

    case "$1" in
	gmp)
	    HOST_CC=gcc CPPFLAGS=-fexceptions \
		build_generic $1 $OPTS \
		--enable-cxx || exit 1
	    ;;

	mpfr)
	    build_generic $1 $OPTS \
		--enable-shared || exit 1
	    ;;

	ppl)
	    setup_generic $1 &&
	    configure_generic $1 $OPTS \
		--enable-interfaces="c,cxx" \
		--enable-shared \
		--disable-optimization \
		--with-libgmp-prefix=$PREFIX_FINAL \
		--with-libgmpxx-prefix=$PREFIX_FINAL || exit 1

	    pushd $builddir || exit 1
	    # CLFS: Wwhen PPL is cross-compiled, it does not check whether
	    # GMP was compiled with support for exceptions, and simply
	    # assumes it was not. This assumption is incorrect, so we will
	    # fix that:
	    echo '#define PPL_GMP_SUPPORTS_EXCEPTIONS 1' >> confdefs.h &&
	    popd || exit 1
	    
	    compile_generic $1 || exit 1
	    ;;

	cloog-ppl)
	    build_generic $1 $OPTS \
		--with-bits=gmp \
		--enable-shared \
		--with-gmp=$PREFIX_FINAL \
		--with-ppl=$PREFIX_FINAL || exit 1
	    ;;

	zlib)
	    # zlib doesn't support out-of-tree builds...
	    setup_generic $1 || exit 1
	    export builddir=$sourcedir

	    # and it doesn't use autotools... despite the "configure" script
	    # and autotool-ish configure flags
	    OPTS="--prefix=$PREFIX_FINAL"
	    OPTS+=" --libdir=$PREFIX_FINAL/lib64"
	    pushd $builddir &&
	    ./configure $OPTS &&
	    popd || exit 1

	    compile_generic $1 || exit 1
	    ;;

	binutils)
	    setup_generic $1 &&
	    configure_generic $1 $OPTS \
		--with-lib-path=$PREFIX_FINAL/lib64:$PREFIX_FINAL/lib \
		--disable-nls \
		--enable-shared \
		--enable-64-bit-bfd || exit 1

	    pushd $builddir &&
	    make configure-host &&
	    make -j3 &&
	    make install &&
	    popd || exit 1
	    ;;

	gcc)
	    setup_generic gcc || exit 1

	    if [ ! -f $builddir/Makefile ]; then
		pushd $sourcedir || exit 1
		# apply bootstrap patches from the bootstrap-cross stage.
		for p in $toplevel/utils/bootstrap-cross/patches/gcc/*.patch; do
		    patch -Np1 < $p || exit 1
		done

		# revert this one bootstrap-cross patch
		patch -R -Np1 < $toplevel/utils/bootstrap-cross/patches/gcc/0003-set-CROSS_SYSTEM_HEADER_DIR.patch || exit 1

		# and apply final bootstrap patches
		for p in $toplevel/utils/bootstrap/patches/gcc/*.patch; do
		    patch -Np1 < $p || exit 1
		done
		popd
	    fi

	    configure_generic $1 $OPTS \
		--target=${MACHTYPE_TARGET} \
		--with-local-prefix=$PREFIX_FINAL \
		--enable-long-long \
		--enable-c99 \
		--enable-shared \
		--enable-threads=posix \
		--enable-__cxa_atexit \
		--disable-nls \
		--enable-languages=c,c++ \
		--disable-libstdcxx-pch || exit 1

	    pushd $builddir || exit 1
	    #  The following will prevent GCC from looking in the wrong
	    #  directories for headers and libraries
	    sed -i "/^HOST_\(GMP\|PPL\|CLOOG\)\(LIBS\|INC\)/s:-[IL]/\(lib\|include\)::" Makefile || exit 1

	    make -j3 AS_FOR_TARGET="${AS}" LD_FOR_TARGET="${LD}" &&
	    make install &&
	    popd || exit 1
	    ;;

	ncurses)
	    build_generic $1 $OPTS \
		--with-shared \
		--without-debug \
		--without-ada \
		--enable-overwrite \
		--with-build-cc=gcc || exit 1
		;;

	busybox)
	    setup_generic $1 || exit 1

	    pushd $builddir || exit 1

	    # create .config
	    #
	    # NOTE: planning on using the busybox variants of everything
	    #       possible except for programs provided by the following
	    #       packages:
	    #
	    #       - e2fsprogs (blkid, findfs, fsck.ext2, mkfs.ext2, etc)
	    #
	    # NOTE: We're not using PAM here... might want to add this into
	    #       our final busybox config (assuming we actually compile
	    #       the PAM libs first).
	    #
	    # NOTE: if you want to do a make menuconfig to tweak .config,
	    #       NCURSES_PREFIX has to be set to $PREFIX_FINAL.
	    cp $packagedir/$1/config-bootstrap .config &&
	    make KBUILD_SRC=$sourcedir -f $sourcedir/Makefile oldconfig || exit 1

	    # build
	    make -j3 ARCH=${ARCH_TARGET} \
		CROSS_COMPILE="${MACHTYPE_TARGET}-" || exit 1

	    # install
	    make ARCH=${ARCH_TARGET} \
		CROSS_COMPILE="${MACHTYPE_TARGET}-" \
		CONFIG_PREFIX=$PREFIX_FINAL install || exit 1

	    # FIXME: there are a bunch of config files in
	    #        $sourcedir/examples that we might want installed too
	    #cp $sourcedir/examples/depmod.pl $PREFIX_FINAL/bin &&
	    #chmod 755 $PREFIX_FINAL/bin/depmod.pl|| exit 1

	    popd

	    ;;

	flex)
	    setup_generic $1 || exit 1

	    # Make sure that Flex doesn't try to include headers from
	    # /usr/include.
	    pushd $sourcedir &&
	    sed -i "s/-I@includedir@//g" Makefile.in &&
	    popd || exit 1

	     # When Cross Compiling the configure script does not determine
	     # the correct values for the following, Set the values
	     # manually
	    pushd $builddir &&
	    echo ac_cv_func_malloc_0_nonnull=yes > config.cache &&
	    echo ac_cv_func_realloc_0_nonnull=yes >> config.cache &&
	    popd || exit 1

	    configure_generic $1 $OPTS \
		--cache-file=config.cache &&
	    compile_generic $1 || exit 1
	    ;;

	gettext)
	    setup_generic $1 || exit

	    # Only the programs in the gettext-tools directory need to be
	    # installed for the temp-system
	    sourcedir=$sourcedir/gettext-tools
	    configure=$sourcedir/configure

	    # When cross-compiling the Gettext configure script assumes we
	    # don't have a working wcwidth when we do. The following will
	    # fix possible compilation errors because of this assumption
	    pushd $builddir &&
	    echo "gl_cv_func_wcwidth_works=yes" > config.cache &&
	    popd || exit 1

	    configure_generic $1 $OPTS \
		--disable-shared \
		--cache-file=config.cache || exit 1

	    pushd $builddir &&
	    make -j3 -C gnulib-lib &&
	    make -j3 -C src msgfmt &&
	    cp -v src/msgfmt $PREFIX_FINAL/bin &&
	    popd || exit 1
	    ;;

	m4)
	    setup_generic $1 || exit 1

	    # Configure can not properly determine the results of the
	    # following tests
	    pushd $builddir &&
	    echo gl_cv_func_btowc_eof=yes > config.cache &&
	    echo gl_cv_func_mbrtowc_incomplete_state=yes >> config.cache &&
	    echo gl_cv_func_mbrtowc_sanitycheck=yes >> config.cache &&
	    echo gl_cv_func_mbrtowc_null_arg=yes >> config.cache &&
	    echo gl_cv_func_mbrtowc_retval=yes >> config.cache &&
	    echo gl_cv_func_mbrtowc_nul_retval=yes >> config.cache &&
	    echo gl_cv_func_wcrtomb_retval=yes >> config.cache &&
	    echo gl_cv_func_wctob_works=yes >> config.cache &&
	    popd || exit 1

	    configure_generic $1 $OPTS \
		--cache-file=config.cache &&
	    compile_generic || exit 1
	    ;;

	texinfo)
	    setup_generic $1 || exit 1

	    # rm configure to force configure_generic to run autoreconf.  we
	    # patch configure.ac, so this is needed.
	    rm -f $sourcedir/configure || exit 1
	    
	    # need to set LDFLAGS like this so that texinfo's bootstrap
	    # native build can find our bootstrap-early stuff (ncurses,
	    # specifically)
	    LDFLAGS=-L$PREFIX_EARLY/lib \
		configure_generic $1 $OPTS || exit 1

	    pushd $builddir &&
	    make -j3 -C tools/gnulib/lib &&
	    make -j3 -C tools &&
	    make -j3 &&
	    make install &&
	    popd || exit 1
	    ;;

	create-dirs)
	    mkdir -pv ${BABY}/{bin,boot,dev,{etc/,}opt,home,lib{,64},mnt}
	    mkdir -pv ${BABY}/{proc,media/{floppy,cdrom},sbin,srv,sys}
	    mkdir -pv ${BABY}/var/{lock,log,mail,run,spool}
	    mkdir -pv ${BABY}/var/{opt,cache,lib{,64}/{misc,locate},local}
	    install -dv ${BABY}/root -m 0750
	    install -dv ${BABY}{/var,}/tmp -m 1777
	    mkdir -pv ${BABY}/usr/{,local/}{bin,include,lib{,64},sbin,src}
	    mkdir -pv ${BABY}/usr/{,local/}share/{doc,info,locale,man}
	    mkdir -pv ${BABY}/usr/{,local/}share/{misc,terminfo,zoneinfo}
	    mkdir -pv ${BABY}/usr/{,local/}share/man/man{1,2,3,4,5,6,7,8}
	    for dir in ${BABY}/usr{,/local}; do
		ln -sv share/{man,doc,info} $dir 2>/dev/null
	    done
	    install -dv ${BABY}/usr/lib/locale
	    ln -sv ../lib/locale ${BABY}/usr/lib64 2>/dev/null
	    echo done
	    ;;

	create-symlinks)
	    ln -sv $PREFIX_FINAL/bin/{bash,cat,echo,grep,pwd,sleep,stty} ${BABY}/bin 2>/dev/null
	    ln -sv $PREFIX_FINAL/bin/file ${BABY}/usr/bin 2>/dev/null
	    ln -sv $PREFIX_FINAL/lib/libgcc_s.so{,.1} ${BABY}/usr/lib 2>/dev/null
	    ln -sv $PREFIX_FINAL/lib64/libgcc_s.so{,.1} ${BABY}/usr/lib64 2>/dev/null
	    ln -sv $PREFIX_FINAL/lib/libstd*so* ${BABY}/usr/lib 2>/dev/null
	    ln -sv $PREFIX_FINAL/lib64/libstd*so* ${BABY}/usr/lib64 2>/dev/null

	    # CLFS used bash for this one, but we're using busybox's ash
	    # instead.  in case we change this later, we just symlink our
	    # bootstrap sh symlink to our baby system's /bin/sh
	    ln -sv $PREFIX_FINAL/bin/sh ${BABY}/bin/sh 2>/dev/null

	    # we've got some more symlinks to make, because we use our
	    # boostrap busybox install in place of a bunch of extra packages
	    # that CLFS installs directly in the baby system.  the easiest
	    # thing to do here, is just make symlinks to all the busybox
	    # symlinks in the baby system by parsing busybox.links in
	    # busybox's builddir
	    for x in $(cat .build/busybox/build/busybox.links); do
		ln -sv $PREFIX_FINAL$x $BABY$x 2>/dev/null
	    done
	    
	    echo done
	    ;;

	e2fsprogs)
	    setup_generic $1 || exit 1

	    # Change the library directory to lib64
	    pushd $sourcedir &&
	    sed -i '/libdir.*=.*\/lib/s@/lib@/lib64@g' configure &&
	    popd || exit 1

	    PKG_CONFIG=true configure_generic $1 $OPTS \
		--disable-fsck || exit 1

	    pushd $builddir &&
	    make -j3 &&
	    make install || exit 1

	    # NOTE: we don't compile/install the libblkid, libuuid, etc,
	    #       shared libs here.  I ran into cross-compilation problems
	    #       here, and they're not needed.  We'll build and install
	    #       them when we do our final e2fsprogs build later on.
	    #make install-libs || exit 1
	    
	    # make needed symlinks in baby
	    ln -sv $PREFIX_FINAL/sbin/{fsck.ext2,fsck.ext3,fsck.ext4,e2fsck} ${BABY}/sbin 2>/dev/null
	    echo done
	    ;;

	*)
	    build_generic $1 $OPTS || exit 1
	    ;;
    esac
}


packages=""
packages+=" gmp"
packages+=" mpfr"
packages+=" mpc"
packages+=" ppl"
packages+=" cloog-ppl"
packages+=" zlib"
packages+=" binutils"
packages+=" gcc"
packages+=" ncurses"
packages+=" busybox"
packages+=" bison"
packages+=" file"
packages+=" flex"
packages+=" gettext"
packages+=" m4"
packages+=" make"
packages+=" texinfo"


# FIXME: hmm... not sure how i'm gonna do this...  CLFS builds a bunch of
#        basic utils, udev, and a stripped down kernel in the target
#        filesystem (ie, not /bootstrap) to make a bootable system.  Then
#        the next chapter in CLFS overwrites the installed files with the
#        final versions.  I guess this is doable...  The final system
#        packages are going to be packaged and installed with SRP, so we'll
#        have backup files all over the place that need to be remove.
#        Additionally, it would be nice if we could guarantee that there are
#        no bootstrap files left over.  Not sure how important that is,
#        though.
#
# FIXME: CLFS installs util-linux-ng at this point... we're using busybox as
#        a replacement and it's already installed in /bootstrap...  Do the
#        util-linux portions of it really need to be in the proper places?
#        or will /bootstrap do?  If /bootstrap isn't good enough for that
#        part of busybox, why not just install the whole darn thing in the
#        baby filesystem and let it all be overwritten by the busybox srp
#        later on...?
#
#        Actually, it might be simpler (at least for now) to install
#        symlinks for all the busybox binaries that got intsalled in
#        /bootstrap in /bin, /sbin, etc.
#
# FIXME: hey, busybox installs a udev replacement called 'mdev'... should we
#        use that instead of udev for our bootstrap boot?  we could either
#        not compile it later on (and make sure we remove the bootstrap
#        version), or just leave it and make sure out bootscripts use udev
#        intead.  using mdev instead of udev will probably not fly well down
#        the road if we really want our development desktops to be built on
#        top of our base-most image...  maybe the final dev image switches
#        over to udev.  or it might be simpler to use udev all the way
#        through... it can't add that much space


# boot prep
packages+=" create-dirs"
packages+=" create-symlinks"

# more boot packages
packages+=" e2fsprogs"

# FIXME: mdev vs udev.  I suspect that if we base our desktop image on our
#        embedded image, parts of the desktop (GNOME, KDE, etc) are going to
#        require udev.  Modern versions of udev, however, don't appear to
#        play well with busybox's (or e2fsprogs') versions of blkid and
#        libuuid.  So, our final system might want to use util-linux-ng and
#        udev instead of busybox's mdev setup.  Not really sure how best to
#        handle this yet.  Anyway, it's probably simpler for our bootable
#        bootstrap system to just use busybox's mdev for now.
#packages+=" udev"

# this will handle config files for init, mdev, users/groups, logfiles,
# login scripts, fstab, needed device nodes, etc
packages+=" create-conf"

packages+=" bootscripts"
packages+=" kernel"

# CLFS doesn't install grub at this point, but if we're going to automate
# the whole build process (ie, automaticaly reboot into the baby system),
# we'll need to not only install it on the system, we'll have to actually
# install it in the MBR and configure it appropriately...
#packages+=" grub"

# NOTE: The following CLFS /tools packages are replaced by our busybox
#       package's equivilent tools
#
#packages+=" bash"
#packages+=" coreutils"
#packages+=" diffutils"
#packages+=" findutils" # missing locate...
#packages+=" gawk"
#packages+=" grep"
#packages+=" gzip"
#packages+=" patch"
#packages+=" sed"
#packages+=" tar"
#packages+=" vim"
#packages+=" xz-utils"

# NOTE: The following CLFS /tools packages (for booting) are currently
#       replaced by our busybox package... but we might want to actually
#       install the real versions.  util-linux-ng, for example, installs
#       pkg-config files that are searched for when building udev and/or hal
#       later on...
#
#packages+=" util-linux-ng"
#packages+=" sysvinit"
#packages+=" module-init-tools"

# NOTE: The following CLFS final system packages are replaced by our busybox
#       package's equivilent tools
#
#packages+=" inetd"
#packages+=" less/more"
#packages+=" iproute2"

# NOTE: The following non-CLFS packages are also replaced by our busybox
#       setup
#
#packages+=" cpio"
#packages+=" rpm"
#packages+=" httpd"
#packages+=" dhcpd"
#packages+=" dhcpclient"
#pacakges+=" bind"

mkdir -p $PWD/.build

for p in $packages; do
    echo "building final bootstrap package: $p"
    build $p || exit 1
done
